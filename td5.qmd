---
format: 
  pdf:
    documentclass: article
    classoption: ["a4paper", "12pt", "fleqn"]
    geometry: top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm
    number-sections: true
    number-depth: 8
    toc: true
header-includes: |
  \usepackage{hyperref}  % Liens cliquables
  \hypersetup{hidelinks}  % Désactive complètement la mise en couleur des liens
editor: 
  markdown: 
    wrap: 72
---

\begin{titlepage}
    \begin{center}
        {\LARGE \textbf{Séries temporelles univariées}}\\
        \vspace{0.5cm}
        {\Large M1 ECAP -- TD5 -- Année 2024/2025}\\
        
        \vspace{2cm}
        
          {\Large \textbf{TD5 : Évaluation de modèles de prévision}}\\
        \vspace{0.5cm}
        \textit{Responsable d'enseignement : Benoît SÉVI}\\
        \href{mailto:benoit.sevi@univ-nantes.fr}{benoit.sevi@univ-nantes.fr}\\
        
        \vspace{1.5cm}
        
        {\large \textbf{ERNOUL DE LA PROVOTÉ Arthur, HERVÉ Isaline}}
        
        \vfill
        
        {\large \today}
        
    \end{center}
\end{titlepage}
\begingroup
\hypersetup{linkcolor=black}
\tableofcontents
\endgroup

\newpage

# Chargement des packages nécessaires

```{r}
#| output: false

# libraries isaline
library(readxl)
library(forecast)
library(sandwich)
library(lmtest)
library(tseries)


# libraries arthur





```

# Import des données

```{r}
wheat <- read_excel("wheat_support5_STU.xlsx")
```

# Création d'une ts

```{r}
wheat_ts <- ts(wheat$return, start = c(2006, 1), end = c(2022, 1), frequency = 252)
```

# Modélisation ARMA

## Analyse des autocorrélations

```{r}
# Analyse des autocorrélations
par(mfrow=c(1, 2))
acf(wheat_ts, main="Autocorrélation de la série")
pacf(wheat_ts, main="Autocorrélation partielle de la série")
```

L’ACF décroît rapidement vers zéro, ce qui suggère un modèle AR.

La PACF montre quelques valeurs significatives aux premiers retards, indiquant un possible AR(p).

```{r}
# Sélection du meilleur modèle ARMA basé sur AIC/BIC
ar_model <- auto.arima(wheat_ts, max.p = 2, max.q = 0, seasonal = FALSE, stepwise = FALSE, approximation = FALSE)
print(ar_model)
```

D'après auto arima, le meilleur modèle est un modèle ARIMA(0, 0, 0). Donc nousne retiendrons donc pas pour la suite de l'analyse mais un modèle AR(1).

```{r}
# Fonction pour ajuster le modèle sélectionné et faire des prévisions
arma_forecast <- function(y, model, h) {
  forecast(model, h = h)$mean
}
```

# Série de prévision

```{r}
# Rolling windows forecasts
rolling_forecast <- function(y, model, h, window) {
  n <- length(y)
  forecasts <- rep(NA, n)
  
  for (i in (window + 1):(n - h)) {
    y_train <- y[(i - window):(i - 1)]
    model_fit <- Arima(y_train, model=meilleur_modele)
    forecasts[i + h] <- arma_forecast(y_train, model_fit, h)
  }
  return(forecasts)
}
```

## Sur les 10 dernières années : 

### Prévisions en t+1

```{r}
a10_forecasts_1d <- rolling_forecast(wheat_ts, meilleur_modele, h = 1, window = 10 * 252)
```

### Prévisions en t+5

```{r}
a10_forecasts_5d <- rolling_forecast(wheat_ts, meilleur_modele, h = 5, window = 10 * 252)
```

## Sur les 3 dernières années : 

### Prévisions en t+1

```{r}
a3_forecasts_1d <- rolling_forecast(wheat_ts, meilleur_modele, h = 1, window = 3 * 252)
```

### Prévisions en t+5

```{r}
a3_forecasts_5d <- rolling_forecast(wheat_ts, meilleur_modele, h = 5, window = 3 * 252)
```

# Modèle marche aléatoire

## Prévisions en t+1

```{r}
rw_forecasts_1d <- lag(wheat_ts, -1)
```

## Prévisions en t+5

```{r}
rw_forecasts_5d <- lag(wheat_ts, -5)
```

# Comparaison des erreurs

```{r}
# Fonction de perte (ex. erreur quadratique moyenne - MSE)
mse <- function(y, yhat) { mean((y - yhat)^2, na.rm = TRUE) }

mse_A10_1d <- mse(wheat_ts, a10_forecasts_1d)
mse_A3_1d <- mse(wheat_ts, a3_forecasts_1d)
mse_RW_1d <- mse(wheat_ts, rw_forecasts_1d)

mse_A10_5d <- mse(wheat_ts, a10_forecasts_5d)
mse_A3_5d <- mse(wheat_ts, a3_forecasts_5d)
mse_RW_5d <- mse(wheat_ts, rw_forecasts_5d)
```


# Mincer-Zarnovitz

## Fonction de test de Mincer-Zarnowitz

```{r}
mz_test <- function(y, yhat) {
  model <- lm(y ~ yhat)
  summary(model)
}
```

## Modèle A10

```{r}
MZ_A10_1d <- mz_test(wheat_ts, a10_forecasts_1d)
MZ_A10_5d <- mz_test(wheat_ts, a10_forecasts_5d)
```

## Modèle A3

```{r}
MZ_A3_1d <- mz_test(wheat_ts, a3_forecasts_1d)
MZ_A3_5d <- mz_test(wheat_ts, a3_forecasts_5d)
```

## Marche aléatoire

```{r}
MZ_RW_1d <- mz_test(wheat_ts, rw_forecasts_1d)
MZ_RW_5d <- mz_test(wheat_ts, rw_forecasts_5d)
```

## Résultats 

```{r}
print("Test Mincer-Zarnowitz pour A10")
print(MZ_A10_1d)
print(MZ_A10_5d)

print("Test Mincer-Zarnowitz pour A3")
print(MZ_A3_1d)
print(MZ_A3_5d)

print("Test Mincer-Zarnowitz pour RW")
print(MZ_RW_1d)
print(MZ_RW_5d)
```

Le test de Mincer-Zarnowitz permet de tester si les prévisions sont non biaisées et efficaces par rapport aux observations réelles.
L'hypothèse nulle correspond à des prévisions parfaites ; si H0 est rejettée, le modèle de prévision est biaisée.

# Statistique de Diebold et Mariano

```{r}
# Charger les bibliothèques nécessaires
library(forecast)
library(sandwich)
library(lmtest)

# Fonction de perte MAE
mae <- function(y, yhat) { mean(abs(y - yhat), na.rm = TRUE) }

# Calculer les pertes pour chaque modèle
loss_A10_1d_mse <- (wheat_ts - a10_forecasts_1d)^2
loss_RW_1d_mse <- (wheat_ts - rw_forecasts_1d)^2

loss_A10_1d_mae <- abs(wheat_ts - a10_forecasts_1d)
loss_RW_1d_mae <- abs(wheat_ts - rw_forecasts_1d)

# Calculer la différence des pertes
delta_mse <- loss_RW_1d_mse - loss_A10_1d_mse
delta_mae <- loss_RW_1d_mae - loss_A10_1d_mae

# Estimer la régression
reg_mse <- lm(delta_mse ~ 1)
reg_mae <- lm(delta_mae ~ 1)

# Estimer la covariance des erreurs avec Newey-West
cov_mse <- NeweyWest(reg_mse, lag = 5)
cov_mae <- NeweyWest(reg_mae, lag = 5)

# Réaliser le test t
test_mse <- coeftest(reg_mse, cov_mse)
test_mae <- coeftest(reg_mae, cov_mae)

# Afficher les résultats
print(test_mse)
print(test_mae)

```


