---
format: 
  pdf:
    documentclass: article
    classoption: ["a4paper", "12pt", "fleqn"]
    geometry: top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm
    number-sections: true
    number-depth: 8
    toc: true
header-includes: |
  \usepackage{hyperref}  % Liens cliquables
  \hypersetup{hidelinks}  % Désactive complètement la mise en couleur des liens
editor: 
  markdown: 
    wrap: 72
---

\begin{titlepage}
    \begin{center}
        {\LARGE \textbf{Séries temporelles univariées}}\\
        \vspace{0.5cm}
        {\Large M1 ECAP -- TD5 -- Année 2024/2025}\\
        
        \vspace{2cm}
        
          {\Large \textbf{TD5 : Évaluation de modèles de prévision}}\\
        \vspace{0.5cm}
        \textit{Responsable d'enseignement : Benoît SÉVI}\\
        \href{mailto:benoit.sevi@univ-nantes.fr}{benoit.sevi@univ-nantes.fr}\\
        
        \vspace{1.5cm}
        
        {\large \textbf{ERNOUL DE LA PROVOTÉ Arthur, HERVÉ Isaline}}
        
        \vfill
        
        {\large \today}
        
    \end{center}
\end{titlepage}
\begingroup
\hypersetup{linkcolor=black}
\tableofcontents
\endgroup

\newpage

# Chargement des packages nécessaires

```{r}
#| output: false

# libraries isaline
library(readxl)
library(forecast)
library(sandwich)
library(lmtest)
library(tseries)


# libraries arthur





```

# Import des données

```{r}
wheat <- read_excel("wheat_support5_STU.xlsx")
```

# Création d'une ts

```{r}
wheat_ts <- ts(wheat$return, start = c(2006, 1), end = c(2022, 1), frequency = 252)
```

# Modélisation ARMA

## Analyse des autocorrélations

```{r}
# Analyse des autocorrélations
acf(wheat_ts, main="Autocorrélation de la série")
pacf(wheat_ts, main="Autocorrélation partielle de la série")
```


```{r}
# Sélection du meilleur modèle ARMA basé sur AIC/BIC
meilleur_modele <- auto.arima(wheat_ts, seasonal = FALSE, stepwise = FALSE, approximation = FALSE)
print(meilleur_modele)
```

D'après auto arima, le meilleur modèle est un modèle ARMA(2, 3), que nous retiendrons donc pour la suite de l'analyse.

```{r}
# Fonction pour ajuster le modèle sélectionné et faire des prévisions
arma_forecast <- function(y, model, h) {
  forecast(model, h = h)$mean
}
```

# Série de prévision

```{r}
# Rolling windows forecasts
rolling_forecast <- function(y, model, h, window) {
  n <- length(y)
  forecasts <- rep(NA, n)
  
  for (i in (window + 1):(n - h)) {
    y_train <- y[(i - window):(i - 1)]
    model_fit <- Arima(y_train, model=best_model)
    forecasts[i + h] <- arma_forecast(y_train, model_fit, h)
  }
  return(forecasts)
}
```

## Sur les 10 dernières années : 

### Prévisions en t+1

```{r}
a10_forecasts_1d <- rolling_forecast(wheat_ts, meilleur_modele, h = 1, window = 10 * 252)
```

### Prévisions en t+5

```{r}
a10_forecasts_5d <- rolling_forecast(wheat_ts, meilleur_modele, h = 5, window = 10 * 252)
```

## Sur les 3 dernières années : 

### Prévisions en t+1

```{r}
a3_forecasts_1d <- rolling_forecast(wheat_ts, meilleur_modele, h = 1, window = 3 * 252)
```

### Prévisions en t+5

```{r}
a3_forecasts_5d <- rolling_forecast(wheat_ts, meilleur_modele, h = 5, window = 3 * 252)
```

# Modèle marche aléatoire

## Prévisions en t+1

```{r}
rw_forecasts_1d <- lag(wheat_ts, -1)
```

## Prévisions en t+5

```{r}
rw_forecasts_5d <- lag(wheat_ts, -5)
```

# Comparaison des erreurs

```{r}
# Fonction de perte (ex. erreur quadratique moyenne - MSE)
mse <- function(y, yhat) { mean((y - yhat)^2, na.rm = TRUE) }

mse_A10_1d <- mse(wheats_ts, a10_forecasts_1d)
mse_A3_1d <- mse(wheats_ts, a3_forecasts_1d)
mse_RW_1d <- mse(wheats_ts, rw_forecasts_1d)

mse_A10_5d <- mse(wheats_ts, a10_forecasts_5d)
mse_A3_5d <- mse(wheats_ts, a3_forecasts_5d)
mse_RW_5d <- mse(wheats_ts, rw_forecasts_5d)
```


# Mincer-Zarnovitz

## Modèle A10

```{r}

```

## Modèle A3

```{r}

```

# Statistique de Diebold et Mariano

## Modèle A10

```{r}

```

## Modèle A3

```{r}

```

# Comparaison des performances des modèles

```{r}

```

